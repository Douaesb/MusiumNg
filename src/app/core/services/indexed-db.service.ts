import { Injectable } from '@angular/core';
import { openDB, DBSchema, IDBPDatabase } from 'idb';
import { Observable, from } from 'rxjs';

interface MusicStreamDB extends DBSchema {
  audioFiles: {
    key: number;
    value: {
      id?: number;
      fileName: string;
      fileBlob: Blob;
      fileType: string;
      fileSize: number;
      createdAt: Date;
      trackId?: number;  
    };
  };
  tracks: {
    key: number;
    value: {
      id?: number;
      title: string;
      artist: string;
      description?: string;
      category: string;
      duration: number;
      audioFileId?: number;
      createdAt: Date;
    };
  };
}

@Injectable({
  providedIn: 'root',
})
export class IndexedDbService {
  private db!: IDBPDatabase<MusicStreamDB>;

  constructor() {
    this.initDB();
  }
  private async initDB(): Promise<void> {
    try {
      this.db = await openDB<MusicStreamDB>('MusicStreamDB', 1, {
        upgrade(db) {
          if (!db.objectStoreNames.contains('audioFiles')) {
            db.createObjectStore('audioFiles', { keyPath: 'id', autoIncrement: true });
            console.log('audioFiles store created');
          }
          if (!db.objectStoreNames.contains('tracks')) {
            db.createObjectStore('tracks', { keyPath: 'id', autoIncrement: true });
            console.log('tracks store created');
          }
        },
      });
      console.log('IndexedDB Initialized');
    } catch (error) {
      console.error('Error initializing IndexedDB:', error);
    }
  }
  
  
  addAudioFile(audioFile: { fileBlob: Blob; fileName: string; fileType: string; fileSize: number }): Observable<number> {
    return from(
      (async () => {
        await this.ensureDBInitialized();
        const id = await this.db.add('audioFiles', {
          ...audioFile,
          createdAt: new Date(),
        });
        return id; // This is the actual ID generated by IndexedDB
      })()
    );
  }
  
  
  async getAllAudioFiles(): Promise<MusicStreamDB['audioFiles']['value'][]> {
    return this.db.getAll('audioFiles');
  }

  async deleteAudioFile(id: number): Promise<void> {
    await this.db.delete('audioFiles', id);
  }

  private async ensureDBInitialized(): Promise<void> {
    if (!this.db) {
      await this.initDB();
    }
  }
  
  getAllTracks(): Observable<MusicStreamDB['tracks']['value'][]> {
    return from(
      (async () => {
        await this.ensureDBInitialized();  // Ensure DB is initialized
        return this.db.getAll('tracks');
      })()
    );
  }
  
  
  // Tracks Methods
  addTrack(track: MusicStreamDB['tracks']['value']): Observable<number> {
    return from(
      (async () => {
        await this.ensureDBInitialized();
        if (track.description && track.description.length > 200) {
          throw new Error('Description exceeds 200 characters');
        }
        return this.db.put('tracks', { ...track, createdAt: new Date() });
      })()
    );
  }

  updateTrack(track: MusicStreamDB['tracks']['value']): Observable<number> {
    return from(
      (async () => {
        await this.ensureDBInitialized();
        if (track.description && track.description.length > 200) {
          throw new Error('Description exceeds 200 characters');
        }
        if (!track.id) {
          throw new Error('Track ID is required for editing');
        }
        return this.db.put('tracks', { ...track, createdAt: new Date() });
      })()
    );
  }

  deleteTrack(trackId: number): Observable<void> {
    return from(this.db.delete('tracks', trackId));
  }

  async searchTracksByCategory(category: string): Promise<MusicStreamDB['tracks']['value'][]> {
    const tracks = await this.db.getAll('tracks');
    return tracks.filter((track) => track.category.toLowerCase() === category.toLowerCase());
  }

  async addTrackWithAudioFile(
    track: MusicStreamDB['tracks']['value'],
    file: Blob,
    fileName: string,
    fileType: string,
    fileSize: number
  ): Promise<number | null> {
    await this.ensureDBInitialized();
  
    try {
      // Step 1: Create the track first (without the audioFileId)
      const trackId = await this.db.add('tracks', {
        ...track,
        createdAt: new Date(),
      });
  
      console.log(`Track added with ID ${trackId}`);
  
      // Step 2: Add audio file and associate it with the trackId
      const audioFileId = await this.addAudioFile({
        fileBlob: file,
        fileName,
        fileType,
        fileSize,
      }).toPromise();
  
      if (!audioFileId) {
        console.error('Failed to add audio file');
        return null;
      }
  
      // Step 3: Get the audio file by id, and update it with the trackId
      const audioFile = await this.db.get('audioFiles', audioFileId);
      if (audioFile) {
        const updatedAudioFile = {
          ...audioFile, // Spread existing properties of the audio file
          trackId, // Add the trackId reference in the audioFile
        };
  
        // Update the audio file with the associated trackId
        await this.db.put('audioFiles', updatedAudioFile);
        console.log(`Audio file updated with track ID ${trackId}`);
      }
  
      return trackId; // Return the created track ID
  
    } catch (error) {
      console.error('Error adding track with audio file:', error);
      return null;
    }
  }  

// Adjusted method to generate URL for the audio file using Blob
getAudioFileUrl(audioFileId: number): Observable<string> {
  return from(
    (async () => {
      await this.ensureDBInitialized();
      // Get the audio file from IndexedDB by its ID
      const audioFile = await this.db.get('audioFiles', audioFileId);
      if (audioFile) {
        // Create and return an Object URL for the Blob
        return URL.createObjectURL(audioFile.fileBlob);
      }
      throw new Error('Audio file not found');
    })()
  );
}

  
}
